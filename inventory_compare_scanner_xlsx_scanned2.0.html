<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Inventory Compare & Scan — CSV/XLSX (Remaining shows Scanned) + Per-row Shot Button</title>
<style>
  :root {
    --bg: #0f172a; --panel: #111827; --panel2: #0b1220; --text: #e5e7eb;
    --muted: #9ca3af; --accent: #22c55e; --warn: #f59e0b; --error: #ef4444; --border: #1f2937;
  }
  * { box-sizing: border-box; }
  body { margin:0; background: radial-gradient(1200px 800px at 20% 10%, #0b1430, #0a0f1f 45%, var(--bg) 100%);
         color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.45; }
  header { padding:18px 20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
           position:sticky; top:0; z-index:5; display:flex; gap:16px; align-items:center; justify-content:space-between; }
  .brand { display:flex; gap:12px; align-items:center; }
  .logo { width:36px; height:36px; border-radius:8px; background: linear-gradient(135deg, #1d4ed8, #16a34a); box-shadow: 0 8px 30px rgba(0,0,0,0.3), inset 0 0 0 1px rgba(255,255,255,0.08); }
  h1 { margin:0; font-size:20px; font-weight:700; }
  .container { padding:20px; max-width:1200px; margin:0 auto; }
  .grid { display:grid; grid-template-columns:1fr; gap:18px; }
  @media (min-width: 900px) { .grid { grid-template-columns: 1.2fr 1fr; } }
  .card { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
          border:1px solid var(--border); border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; }
  .card h2 { margin-top:0; font-size:18px; }
  .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  input[type="file"], textarea, input[type="text"], select {
    background: var(--panel2); color: var(--text); border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-size:14px; outline:none;
  }
  textarea { width:100%; min-height:110px; resize:vertical; }
  input#scanInput { font-size:22px; padding:14px 16px; width:100%; letter-spacing:1px; font-weight:600; }
  button { background:#111827; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600; transition:0.15s transform ease, 0.15s background ease; }
  button:hover { transform: translateY(-1px); background:#0d1322; }
  button.primary { background:#1f2937; border-color:#243042; }
  button.danger { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.4); }
  .small { font-size:12px; color:var(--muted); }
  .badge { font-size:11px; padding:3px 8px; border-radius:999px; border: 1px solid var(--border); background: rgba(255,255,255,0.04); }
  .kpi { display:grid; grid-template-columns: repeat(3,1fr); gap:12px; margin-top:10px; }
  .kpi .box { border:1px solid var(--border); border-radius:12px; padding:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); text-align:center; }
  .kpi .value { font-size:22px; font-weight:800; }
  .kpi .label { font-size:12px; color:var(--muted); margin-top:4px; }
  table { width:100%; border-collapse:collapse; font-size:13px; }
  th, td { border-bottom:1px solid var(--border); padding:8px; text-align:left; }
  th { color:var(--muted); font-weight:600; }
  tr.ok td { background: rgba(34,197,94,0.05); }
  tr.short td { background: rgba(245,158,11,0.06); }
  tr.over td { background: rgba(239,68,68,0.06); }
  .pill { padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border); }
  .pill.ok { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.35); }
  .pill.short { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.35); }
  .pill.over { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.35); }
  .log { max-height:180px; overflow:auto; border:1px solid var(--border); border-radius:12px; padding:10px; background:var(--panel2); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
  details { border:1px solid var(--border); border-radius:12px; padding:10px 12px; background: rgba(255,255,255,0.02); }
  summary { cursor:pointer; }
  .modal {
    position: fixed; inset: 0; display:none; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.45); z-index: 60;
  }
  .modal .panel {
    width: min(640px, 92vw); background: #0e1528; border:1px solid var(--border); border-radius:14px; padding:16px;
    box-shadow: 0 25px 80px rgba(0,0,0,0.45);
  }

  /* ADDED: tiny action buttons inside tables for per-row actions */
  button.mini { padding:6px 10px; font-size:12px; border-radius:8px; }
</style>
</head>
<body>
<header>
  <div class="brand"><div class="logo"></div><h1>Inventory Compare & Live Scan — CSV/XLSX</h1></div>
  <div class="row">
    <button id="exportBtn" class="primary">Export CSV</button>
    <button id="clearBtn" class="danger">Clear Session</button>
  </div>
</header>

<div class="container">
  <div class="grid">
    <div class="card">
      <h2>1) Load Master Inventory (CSV or Excel)</h2>
      <div class="row">
        <input type="file" id="masterFile" accept=".csv, text/csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel, .xlsx, .xls" />
        <button id="loadMasterBtn" class="primary">Load File</button>
        <span class="small">Supported: <b>CSV</b> or <b>.xlsx/.xls</b>. Then map columns if needed.</span>
      </div>
      <details style="margin-top:10px;">
        <summary class="small">Or paste (CSV or Excel clipboard)</summary>
        <textarea id="masterPaste" placeholder="Paste rows here — we accept CSV or tab-delimited from Excel"></textarea>
        <div class="row" style="margin-top:8px;">
          <button id="loadPasteBtn">Load Pasted Data</button>
          <span class="small">We’ll try to detect header row automatically.</span>
        </div>
      </details>

      <h2 style="margin-top:18px;">2) Scan or Type Items</h2>
      <div class="row" style="gap:10px;">
        <input id="scanInput" type="text" placeholder="Click here, then scan a barcode or type SKU and press Enter" autocomplete="off" />
        <button id="undoBtn">Undo Last</button>
        <span class="badge">Keyboard-wedge scan guns supported</span>
      </div>

      <div style="margin-top:12px;" class="row">
        <label><input type="checkbox" id="optCase" checked/> Case-insensitive</label>
        <label><input type="checkbox" id="optTrim" checked/> Trim whitespace</label>
        <label><input type="checkbox" id="optIgnoreWS" checked/> Remove all spaces</label>
        <label><input type="checkbox" id="optDropNonAlnum" checked/> Drop non-alphanumerics</label>
        <label><input type="checkbox" id="optStripZeros"/> Strip leading zeros</label>
        <label><input type="checkbox" id="optBeep" checked/> Beep</label>
      </div>

      <div class="kpi">
        <div class="box"><div class="value" id="kExpected">0</div><div class="label">Distinct SKUs (master)</div></div>
        <div class="box"><div class="value" id="kExpectedQty">0</div><div class="label">Total expected qty</div></div>
        <div class="box"><div class="value" id="kScannedQty">0</div><div class="label">Total scanned qty</div></div>
      </div>

      <div style="margin-top:14px;">
        <div class="log" id="log"></div>
        <div class="small" style="margin-top:6px; color:var(--muted)">Use <b>Undo Last</b> to revert the last scan.</div>
      </div>
    </div>

    <div class="card">
      <h2>Status</h2>
      <div class="kpi" style="grid-template-columns: repeat(2,1fr);">
        <div class="box"><div class="value" id="kRemainingQty">0</div><div class="label">Qty remaining to find</div></div>
        <div class="box"><div class="value" id="kUnknownQty">0</div><div class="label">Unknown scans</div></div>
      </div>
      <h3 style="margin-top:16px;">Unknown items</h3>
      <div style="max-height: 220px; overflow:auto;">
        <table id="unknownTable"><thead><tr><th>SKU</th><th>Count</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:18px;">
    <h2>Remaining</h2>
    <div style="max-height: 260px; overflow:auto;">
      <!-- ADDED: An Action column to enable per-row Shot button -->
      <table id="remainingTable">
        <thead>
          <tr><th>SKU</th><th>Description</th><th>Scanned</th><th>Remaining</th><th>Action</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" style="margin-top:18px;">
    <h2>Matched Summary</h2>
    <div style="max-height: 320px; overflow:auto;">
      <table id="matchedTable">
        <thead><tr><th>SKU</th><th>Description</th><th>Expected</th><th>Scanned</th><th>Over</th><th>Status</th></tr></thead><tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Column mapping modal for CSV/XLSX headers -->
  <div class="modal" id="mapModal">
    <div class="panel">
      <h3 style="margin-top:0;">Map your Excel/CSV columns</h3>
      <p class="small">Choose columns for <b>SKU</b>, <b>Quantity</b>, and (optional) <b>Description</b>.</p>
      <div class="row" style="margin-top:8px;">
        <label>SKU: <select id="mapSku"></select></label>
        <label>Qty: <select id="mapQty"></select></label>
        <label>Desc (optional): <select id="mapDesc"></select></label>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="mapConfirm" class="primary">Use These Columns</button>
        <button id="mapCancel">Cancel</button>
        <span class="small" id="mapPreview"></span>
      </div>
    </div>
  </div>
</div>

<!-- SheetJS for Excel parsing (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" crossorigin="anonymous"></script>

<script>
(() => {
  // ------------------------------
  // APP STATE
  // ------------------------------
  const state = {
    master: new Map(),     // Map(normSku -> { sku, desc, expected, scanned })
    unknown: new Map(),    // Map(normSku -> count) for not-in-master scans
    history: [],           // array of { type:'known'|'unknown', norm, ts, [src] }
    options: { caseInsensitive:true, trim:true, ignoreWhitespace:true, dropNonAlnum:true, stripLeadingZeros:false, beep:true },
    importBuffer: null     // holds rows while user maps columns
  };

  // Cache DOM elements
  const els = {
    masterFile: document.getElementById('masterFile'),
    loadMasterBtn: document.getElementById('loadMasterBtn'),
    masterPaste: document.getElementById('masterPaste'),
    loadPasteBtn: document.getElementById('loadPasteBtn'),
    scanInput: document.getElementById('scanInput'),
    undoBtn: document.getElementById('undoBtn'),
    exportBtn: document.getElementById('exportBtn'),
    clearBtn: document.getElementById('clearBtn'),
    optCase: document.getElementById('optCase'),
    optTrim: document.getElementById('optTrim'),
    optIgnoreWS: document.getElementById('optIgnoreWS'),
    optDropNonAlnum: document.getElementById('optDropNonAlnum'),
    optStripZeros: document.getElementById('optStripZeros'),
    optBeep: document.getElementById('optBeep'),
    kExpected: document.getElementById('kExpected'),
    kExpectedQty: document.getElementById('kExpectedQty'),
    kScannedQty: document.getElementById('kScannedQty'),
    kRemainingQty: document.getElementById('kRemainingQty'),
    kUnknownQty: document.getElementById('kUnknownQty'),
    remainingTable: document.querySelector('#remainingTable tbody'),
    matchedTable: document.querySelector('#matchedTable tbody'),
    unknownTable: document.querySelector('#unknownTable tbody'),
    log: document.getElementById('log'),
    mapModal: document.getElementById('mapModal'),
    mapSku: document.getElementById('mapSku'),
    mapQty: document.getElementById('mapQty'),
    mapDesc: document.getElementById('mapDesc'),
    mapConfirm: document.getElementById('mapConfirm'),
    mapCancel: document.getElementById('mapCancel'),
    mapPreview: document.getElementById('mapPreview')
  };

  const STORAGE_KEY = 'inv-scan-v3-scanned-remaining';

  // ------------------------------
  // PERSISTENCE
  // ------------------------------
  function save() {
    // Save the minimal serializable form to localStorage
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      master: Array.from(state.master.entries()),
      unknown: Array.from(state.unknown.entries()),
      history: state.history,
      options: state.options
    }));
  }
  function load() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try {
      const obj = JSON.parse(raw);
      state.master = new Map(obj.master);
      state.unknown = new Map(obj.unknown);
      state.history = obj.history || [];
      Object.assign(state.options, obj.options || {});
      els.optCase.checked = state.options.caseInsensitive;
      els.optTrim.checked = state.options.trim;
      els.optIgnoreWS.checked = state.options.ignoreWhitespace;
      els.optDropNonAlnum.checked = state.options.dropNonAlnum;
      els.optStripZeros.checked = state.options.stripLeadingZeros;
      els.optBeep.checked = state.options.beep;
      renderAll();
    } catch(e) { console.error(e); }
  }

  // ------------------------------
  // NORMALIZATION & PARSING
  // ------------------------------
  function normalize(s) {
    // Applies the selected normalization options to make matching tolerant
    if (s == null) return '';
    let x = String(s);
    if (state.options.trim) x = x.trim();
    if (state.options.ignoreWhitespace) x = x.replace(/\s+/g, '');
    if (state.options.dropNonAlnum) x = x.replace(/[^0-9A-Za-z]/g, '');
    if (state.options.stripLeadingZeros) x = x.replace(/^0+/, '');
    if (state.options.caseInsensitive) x = x.toUpperCase();
    return x;
  }

  // Simple CSV/TSV parser with quoted-field support (for pasted data or CSV files)
  function parseDelimited(text) {
    const delim = text.indexOf('\t') !== -1 ? '\t' : ',';
    const rows = [];
    let field = '', row = [], inQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') { if (text[i+1] === '"') { field += '"'; i++; } else inQuotes = false; }
        else field += c;
      } else {
        if (c === '"') inQuotes = true;
        else if (c === delim) { row.push(field); field=''; }
        else if (c === '\n') { row.push(field); rows.push(row); row=[]; field=''; }
        else if (c === '\r') { /* skip */ }
        else field += c;
      }
    }
    row.push(field); rows.push(row);
    if (rows.length && rows[rows.length-1].every(x=>x==='')) rows.pop();
    return rows;
  }

  function toHeaderIndex(headers) {
    // heuristic header detection for SKU/Qty/Desc
    const map = {}; headers.forEach((h,i)=> map[String(h||'').trim().toLowerCase()] = i);
    const skuIdx = ['sku','barcode','upc','ean','id','code','item','itemcode','productcode'].map(k => map[k]).find(i => i !== undefined);
    const qtyIdx = ['qty','quantity','count','onhand','on_hand','expected','expectedqty'].map(k => map[k]).find(i => i !== undefined);
    const descIdx = ['description','desc','name','title','product','itemname'].map(k => map[k]).find(i => i !== undefined);
    return { skuIdx, qtyIdx, descIdx, map };
  }

  function loadMasterFromRows(rows, mapping) {
    // Builds the state.master Map from an array-of-arrays (first row = headers)
    if (!rows.length) throw new Error('No rows found');
    let headers = rows[0];
    const idx = mapping || toHeaderIndex(headers);

    // If auto-detect fails, open the mapping modal and stash rows for later
    if (!mapping && (idx.skuIdx === undefined || idx.qtyIdx === undefined)) {
      openMapper(headers, rows.slice(1,6));
      state.importBuffer = rows;
      return;
    }

    const skuIdx = mapping ? mapping.skuIdx : idx.skuIdx;
    const qtyIdx = mapping ? mapping.qtyIdx : idx.qtyIdx;
    const descIdx = mapping ? mapping.descIdx : idx.descIdx;

    const master = new Map();
    let total = 0;
    for (let i = 1; i < rows.length; i++) {
      const r = rows[i]; if (!r || r.length === 0) continue;
      const skuRaw = r[skuIdx] ?? '';
      const qtyRaw = r[qtyIdx] ?? '0';
      const desc = descIdx !== undefined ? (r[descIdx] ?? '') : '';
      const norm = normalize(skuRaw);
      const qty = Number(String(qtyRaw).trim().replace(/,/g,'')) || 0;
      if (!norm) continue;
      if (!master.has(norm)) master.set(norm, { sku: String(skuRaw).trim(), desc: String(desc).trim(), expected: 0, scanned: 0 });
      master.get(norm).expected += qty;
      total += qty;
    }
    state.master = master;
    state.unknown = new Map();
    state.history = [];
    save(); renderAll();
    toast(`Master loaded: ${master.size} SKUs, total qty ${total}`, true);
  }

  async function loadExcel(file) {
    // Parse first worksheet of an Excel file via SheetJS
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, { type: 'array' });
    const sheetName = wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    const aoa = XLSX.utils.sheet_to_json(ws, { header:1, raw:true });
    loadMasterFromRows(aoa);
  }

  // ------------------------------
  // COLUMN MAPPING MODAL
  // ------------------------------
  function openMapper(headers) {
    function fillSelect(sel, opts) {
      sel.innerHTML = '';
      const empty = document.createElement('option'); empty.value=''; empty.textContent='--';
      sel.appendChild(empty);
      opts.forEach((h, i) => { const o = document.createElement('option'); o.value = i; o.textContent = h || `col${i}`; sel.appendChild(o); });
    }
    fillSelect(els.mapSku, headers);
    fillSelect(els.mapQty, headers);
    fillSelect(els.mapDesc, headers);
    const auto = toHeaderIndex(headers);
    if (auto.skuIdx !== undefined) els.mapSku.value = auto.skuIdx;
    if (auto.qtyIdx !== undefined) els.mapQty.value = auto.qtyIdx;
    if (auto.descIdx !== undefined) els.mapDesc.value = auto.descIdx;
    els.mapPreview.textContent = `Headers: ${headers.map(h=>`[${h}]`).join(' ')}`;
    els.mapModal.style.display = 'flex';
  }
  function closeMapper(){ els.mapModal.style.display = 'none'; }

  // ------------------------------
  // SCANNING + NEW MANUAL SHOT FEATURE
  // ------------------------------
  function scan(value) {
    // Handles scans or typed SKUs (Enter)
    const ts = new Date().toISOString();
    const norm = normalize(value);
    if (!norm) return;
    const entry = state.master.get(norm);
    if (entry) {
      entry.scanned += 1;
      state.history.push({ type:'known', norm, ts });
      flash('MATCH: ' + entry.sku, true); beep(true);
    } else {
      const prev = state.unknown.get(norm) || 0;
      state.unknown.set(norm, prev + 1);
      state.history.push({ type:'unknown', norm, ts });
      flash('UNKNOWN: ' + value, false); beep(false);
    }
    if (state.history.length > 5000) state.history.shift();
    save(); renderAll();
  }

  function manualShot(skuOrNorm, amount = 1) {
    // ADDED: increment scanned count from a button click in Remaining table
    const norm = normalize(skuOrNorm);
    const entry = state.master.get(norm);
    if (!entry) { flash('Not in master: ' + skuOrNorm, false); beep(false); return; }
    entry.scanned = (entry.scanned || 0) + amount;
    state.history.push({ type: 'known', norm, ts: new Date().toISOString(), src: 'manual' });
    save(); renderAll(); beep(true);
  }

  function undo() {
    // Reverts the last scan (typed, scanned, or manual)
    const last = state.history.pop();
    if (!last) return;
    if (last.type === 'known') { const e = state.master.get(last.norm); if (e && e.scanned > 0) e.scanned -= 1; }
    else { const c = state.unknown.get(last.norm) || 0; if (c <= 1) state.unknown.delete(last.norm); else state.unknown.set(last.norm, c - 1); }
    save(); renderAll(); toast('Undid last scan', true);
  }

  // ------------------------------
  // RENDERING
  // ------------------------------
  function renderAll() {
    const entries = Array.from(state.master.values());
    const expectedDistinct = entries.length;
    const expectedQty = entries.reduce((a, e) => a + e.expected, 0);
    const scannedQty = entries.reduce((a, e) => a + e.scanned, 0);
    const remainingQty = entries.reduce((a, e) => a + Math.max(0, e.expected - e.scanned), 0);
    const unknownQty = Array.from(state.unknown.values()).reduce((a, n) => a + n, 0);
    els.kExpected.textContent = expectedDistinct;
    els.kExpectedQty.textContent = expectedQty;
    els.kScannedQty.textContent = scannedQty;
    els.kRemainingQty.textContent = remainingQty;
    els.kUnknownQty.textContent = unknownQty;

    // Remaining list (only items still short), sorted by largest remainder
    const remaining = entries
      .filter(e => e.expected - e.scanned > 0)
      .sort((a,b) => (b.expected - b.scanned) - (a.expected - a.scanned) || a.sku.localeCompare(b.sku));

    // ADDED: render an Action button per row to increment scanned without typing
    renderTable(els.remainingTable, remaining.map(e => {
      const normKey = normalize(e.sku);
      return [
        e.sku || '(no sku)',
        e.desc || '',
        String(e.scanned),
        String(Math.max(0, e.expected - e.scanned)),
        `<button class="mini" data-action="shot" data-norm="${normKey}">Shot +1</button>`
      ];
    }));

    // Full matched summary with status highlight
    const matched = entries.slice().sort((a,b)=> a.sku.localeCompare(b.sku));
    renderTable(els.matchedTable, matched.map(e => {
      const over = Math.max(0, e.scanned - e.expected);
      const status = over > 0 ? 'over' : (e.scanned < e.expected ? 'short' : 'ok');
      return { rowClass: status, cells: [e.sku||'(no sku)', e.desc||'', String(e.expected), String(e.scanned), String(over), `<span class="pill ${status}">${status.toUpperCase()}</span>`] };
    }), true);

    // Unknown items summary
    const unkRows = Array.from(state.unknown.entries()).sort((a,b)=> b[1]-a[1]).map(([norm,count])=>[norm, String(count)]);
    renderTable(els.unknownTable, unkRows);

    // Recent log
    const logLines = state.history.slice(-50).map(h => {
      const time = new Date(h.ts).toLocaleTimeString();
      if (h.type === 'known') { const e = state.master.get(h.norm); return `[${time}] OK  → ${e ? e.sku : h.norm}${h.src==='manual' ? ' (manual)' : ''}`; }
      else return `[${time}] ??? → ${h.norm}`;
    });
    els.log.textContent = logLines.reverse().join('\n');
  }

  function renderTable(tbody, rows, withClass=false) {
    tbody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      if (withClass && r.rowClass) tr.className = r.rowClass;
      const cells = withClass ? r.cells : r;
      for (const c of cells) {
        const td = document.createElement('td');
        // allow a bit of inline HTML for status pills / buttons
        if (typeof c === 'string' && c.startsWith('<')) td.innerHTML = c; else td.textContent = c;
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }

  // ------------------------------
  // AUDIO + TOAST FEEDBACK
  // ------------------------------
  let audioCtx = null;
  function ensureAudio(){ if (!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} } }
  function beep(ok){ if(!state.options.beep) return; ensureAudio(); if(!audioCtx) return;
    const duration = ok?0.08:0.18, freq= ok?850:220;
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = ok ? 'square' : 'sawtooth'; osc.frequency.value=freq; osc.connect(gain); gain.connect(audioCtx.destination);
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.06, audioCtx.currentTime+0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+duration); osc.start(); osc.stop(audioCtx.currentTime+duration+0.02);
  }
  function flash(msg, ok){ const overlay = document.createElement('div'); overlay.style.cssText="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:50";
    const bubble = document.createElement('div'); bubble.textContent = msg; bubble.style.cssText = "padding:14px 22px;border-radius:12px;font-size:18px;font-weight:700;border:1px solid var(--border);box-shadow:0 10px 40px rgba(0,0,0,0.35);background:" + (ok?"rgba(34,197,94,0.2)":"rgba(239,68,68,0.2)");
    overlay.appendChild(bubble); document.body.appendChild(overlay); setTimeout(()=>overlay.remove(), 600); }
  function toast(msg, ok){ flash(msg, ok); }

  // ------------------------------
  // OPTIONS + EVENTS
  // ------------------------------
  function setOptionsFromUI() {
    state.options.caseInsensitive = els.optCase.checked;
    state.options.trim = els.optTrim.checked;
    state.options.ignoreWhitespace = els.optIgnoreWS.checked;
    state.options.dropNonAlnum = els.optDropNonAlnum.checked;
    state.options.stripLeadingZeros = els.optStripZeros.checked;
    state.options.beep = els.optBeep.checked;
    save();
  }
  [els.optCase, els.optTrim, els.optIgnoreWS, els.optDropNonAlnum, els.optStripZeros, els.optBeep]
    .forEach(el => el.addEventListener('change', () => { setOptionsFromUI(); renderAll(); }));

  function focusScan(){ els.scanInput.focus({ preventScroll:true }); }
  document.addEventListener('click', focusScan);
  window.addEventListener('focus', focusScan);

  // Scan input: Enter key or wedge scanners that append a newline
  els.scanInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      const v = e.currentTarget.value; e.currentTarget.value='';
      if (v) scan(v); e.preventDefault();
    }
  });
  els.scanInput.addEventListener('input', (e)=>{
    const v = e.currentTarget.value;
    if (v && v.endsWith('\\n')) { e.currentTarget.value = v.replace(/\\n+$/,''); if (e.currentTarget.value) scan(e.currentTarget.value); e.currentTarget.value=''; }
  });

  els.undoBtn.addEventListener('click', undo);
  els.clearBtn.addEventListener('click', ()=>{ if (!confirm('Clear current session (master, scans, options)?')) return;
    state.master.clear(); state.unknown.clear(); state.history = []; save(); renderAll(); });

  els.exportBtn.addEventListener('click', ()=>{
    // Export reconciliation as CSV
    const rows = [['sku','description','expected_qty','scanned_qty','over','status']];
    for (const e of state.master.values()) {
      const over = Math.max(0, e.scanned - e.expected);
      const status = over > 0 ? 'OVER' : (e.scanned < e.expected ? 'SHORT' : 'OK');
      rows.push([e.sku, e.desc || '', e.expected, e.scanned, over, status]);
    }
    if (state.unknown.size) { rows.push([]); rows.push(['unknown_sku','count']); for (const [sku,count] of state.unknown.entries()) rows.push([sku,count]); }
    const csv = rows.map(r => r.map(cell => { const s = String(cell ?? ''); return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s; }).join(',')).join('\n');
    const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='inventory_reconcile.csv'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  els.loadMasterBtn.addEventListener('click', async ()=>{
    // Load CSV or Excel from file input
    const f = els.masterFile.files?.[0]; if (!f) { alert('Choose a file first.'); return; }
    try {
      if (/\.(xlsx|xls)$/i.test(f.name) || (f.type && (f.type.includes('sheet') || f.type.includes('excel')))) {
        await loadExcel(f);
      } else {
        const text = await f.text(); const rows = parseDelimited(text); loadMasterFromRows(rows);
      }
    } catch (e) { alert(e.message || String(e)); }
  });

  els.loadPasteBtn.addEventListener('click', ()=>{
    // Load data from pasted rows (CSV/TSV)
    const text = els.masterPaste.value;
    if (!text.trim()) { alert('Paste data first.'); return; }
    try { const rows = parseDelimited(text); loadMasterFromRows(rows); } catch(e){ alert(e.message || String(e)); }
  });

  els.mapConfirm.addEventListener('click', ()=>{
    // Apply selected column mapping from modal
    if (!state.importBuffer) return closeMapper();
    const skuIdx = els.mapSku.value === '' ? undefined : Number(els.mapSku.value);
    const qtyIdx = els.mapQty.value === '' ? undefined : Number(els.mapQty.value);
    const descIdx = els.mapDesc.value === '' ? undefined : Number(els.mapDesc.value);
    if (skuIdx === undefined || qtyIdx === undefined) { alert('Please select at least SKU and Qty columns.'); return; }
    closeMapper();
    loadMasterFromRows(state.importBuffer, { skuIdx, qtyIdx, descIdx });
    state.importBuffer = null;
  });
  els.mapCancel.addEventListener('click', ()=>{ state.importBuffer = null; closeMapper(); });

  // ADDED: event delegation to catch clicks on per-row buttons in Remaining table
  els.remainingTable.addEventListener('click', (ev) => {
    const btn = ev.target.closest('[data-action="shot"]');
    if (!btn) return;
    manualShot(btn.dataset.norm, 1);
  });

  // Init
  load();
  function focusScan(){ els.scanInput.focus({ preventScroll:true }); }
  focusScan();
})();
</script>
</body>
</html>
