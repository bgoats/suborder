<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Goats Compare & Scan — CSV/XLSX </title>
<style>
  :root {
    --bg: #0f172a; --panel: #111827; --panel2: #0b1220; --text: #e5e7eb;
    --muted: #9ca3af; --accent: #22c55e; --warn: #f59e0b; --error: #ef4444; --border: #1f2937;
  }
  * { box-sizing: border-box; }
  body { margin:0; background: radial-gradient(1200px 800px at 20% 10%, #0b1430, #0a0f1f 45%, var(--bg) 100%);
         color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height:1.45; }
  header { padding:18px 20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
           position:sticky; top:0; z-index:5; display:flex; gap:16px; align-items:center; justify-content:space-between; }
  .brand { display:flex; gap:12px; align-items:center; }
  .logo { width:36px; height:36px; border-radius:8px; background: linear-gradient(135deg, #1d4ed8, #16a34a); box-shadow: 0 8px 30px rgba(0,0,0,0.3), inset 0 0 0 1px rgba(255,255,255,0.08); }
  h1 { margin:0; font-size:20px; font-weight:700; }
  .container { padding:20px; max-width:1200px; margin:0 auto; }
  .grid { display:grid; grid-template-columns:1fr; gap:18px; }
  @media (min-width: 900px) { .grid { grid-template-columns: 1.2fr 1fr; } }
  .card { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
          border:1px solid var(--border); border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; }
  .card h2 { margin-top:0; font-size:18px; }
  .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  input[type="file"], textarea, input[type="text"], select {
    background: var(--panel2); color: var(--text); border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-size:14px; outline:none;
  }
  textarea { width:100%; min-height:110px; resize:vertical; }
  input#scanInput { font-size:22px; padding:14px 16px; width:100%; letter-spacing:1px; font-weight:600; }
  button { background:#111827; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600; transition:0.15s transform ease, 0.15s background ease; }
  button:hover { transform: translateY(-1px); background:#0d1322; }
  button.primary { background:#1f2937; border-color:#243042; }
  button.danger { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.4); }
  .small { font-size:12px; color:var(--muted); }
  .badge { font-size:11px; padding:3px 8px; border-radius:999px; border: 1px solid var(--border); background: rgba(255,255,255,0.04); }
  .kpi { display:grid; grid-template-columns: repeat(3,1fr); gap:12px; margin-top:10px; }
  .kpi .box { border:1px solid var(--border); border-radius:12px; padding:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); text-align:center; }
  .kpi .value { font-size:22px; font-weight:800; }
  .kpi .label { font-size:12px; color:var(--muted); margin-top:4px; }
  table { width:100%; border-collapse:collapse; font-size:13px; }
  th, td { border-bottom:1px solid var(--border); padding:8px; text-align:left; }
  th { color:var(--muted); font-weight:600; }
  tr.ok td { background: rgba(34,197,94,0.05); }
  tr.short td { background: rgba(245,158,11,0.06); }
  .pill { padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border); }
  .pill.ok { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.35); }
  .pill.short { background: rgba(245,158,11,0.15); border-color: rgba(245,158,11,0.35); }
  .log { max-height:180px; overflow:auto; border:1px solid var(--border); border-radius:12px; padding:10px; background:var(--panel2); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
  details { border:1px solid var(--border); border-radius:12px; padding:10px 12px; background: rgba(255,255,255,0.02); }
  summary { cursor:pointer; }
  .modal { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.45); z-index: 60; }
  .modal .panel { width: min(640px, 92vw); background: #0e1528; border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow: 0 25px 80px rgba(0,0,0,0.45); }
  button.mini { padding:6px 10px; font-size:12px; border-radius:8px; }
</style>
</head>
<body>
<header>
  <div class="brand"><div class="logo"></div><h1>Inventory Compare & Live Scan — CSV/XLSX</h1></div>
  <div class="row">
    <button id="exportBtn" class="primary">Export CSV</button>
    <button id="clearBtn" class="danger">Clear Session</button>
  </div>
</header>

<div class="container">
  <div class="grid">
    <div class="card">
      <h2>1) Load Master Inventory (CSV or Excel)</h2>
      <div class="row">
        <input type="file" id="masterFile" accept=".csv, text/csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel, .xlsx, .xls" />
        <button id="loadMasterBtn" class="primary">Load File</button>
        <span class="small">Supported: <b>CSV</b> or <b>.xlsx/.xls</b>. Then map columns if needed.</span>
      </div>
      <details style="margin-top:10px;">
        <summary class="small">Or paste (CSV or Excel clipboard)</summary>
        <textarea id="masterPaste" placeholder="Paste rows here — we accept CSV or tab-delimited from Excel"></textarea>
        <div class="row" style="margin-top:8px;">
          <button id="loadPasteBtn">Load Pasted Data</button>
          <span class="small">We’ll try to detect header row automatically.</span>
        </div>
      </details>

      <h2 style="margin-top:18px;">2) Scan or Type Items</h2>
      <div class="row" style="gap:10px;">
        <input id="scanInput" type="text" placeholder="Click here, then scan a barcode or type SKU and press Enter" autocomplete="off" />
        <button id="undoBtn">Undo Last</button>
        <span class="badge">Keyboard-wedge scan guns supported</span>
      </div>

      <div style="margin-top:12px;" class="row">
        <label><input type="checkbox" id="optCase" checked/> Case-insensitive</label>
        <label><input type="checkbox" id="optTrim" checked/> Trim whitespace</label>
        <label><input type="checkbox" id="optIgnoreWS" checked/> Remove all spaces</label>
        <label><input type="checkbox" id="optDropNonAlnum" checked/> Drop non-alphanumerics</label>
        <label><input type="checkbox" id="optStripZeros"/> Strip leading zeros</label>
        <label><input type="checkbox" id="optBeep" checked/> Beep</label>
      </div>

      <div class="kpi">
        <div class="box"><div class="value" id="kExpected">0</div><div class="label">Distinct items (master)</div></div>
        <div class="box"><div class="value" id="kExpectedQty">0</div><div class="label">Total expected qty</div></div>
        <div class="box"><div class="value" id="kScannedQty">0</div><div class="label">Total scanned qty</div></div>
      </div>

      <div style="margin-top:14px;">
        <div class="log" id="log"></div>
        <div class="small" style="margin-top:6px; color:var(--muted)">Use <b>Undo Last</b> to revert the last scan.</div>
      </div>
    </div>

    <div class="card">
      <h2>Status</h2>
      <div class="kpi" style="grid-template-columns: repeat(2,1fr);">
        <div class="box"><div class="value" id="kRemainingQty">0</div><div class="label">Qty remaining to find</div></div>
        <div class="box"><div class="value" id="kUnknownQty">0</div><div class="label">Unknown scans</div></div>
      </div>
      <h3 style="margin-top:16px;">Unknown items</h3>
      <div style="max-height: 220px; overflow:auto;">
        <table id="unknownTable"><thead><tr><th>Normalized SKU</th><th>Count</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:18px;">
    <h2>Remaining</h2>
    <div class="row" style="margin:6px 0 8px 0;">
      <input id="filterRemaining" type="text" placeholder="Search Remaining by SKU or description" style="flex:1;" />
    </div>
    <div style="max-height: 260px; overflow:auto;">
      <table id="remainingTable">
        <thead>
          <tr><th>SKU</th><th>Description</th><th>Scanned</th><th>Remaining</th><th>Action</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" style="margin-top:18px;">
    <h2>Matched Summary</h2>
    <div class="row" style="margin:6px 0 8px 0;">
      <input id="filterMatched" type="text" placeholder="Search Matched by SKU or description" style="flex:1;" />
    </div>
    <div style="max-height: 320px; overflow:auto;">
      <table id="matchedTable">
        <thead><tr><th>SKU</th><th>Description</th><th>Expected</th><th>Scanned</th><th>Status</th></tr></thead><tbody></tbody>
      </table>
    </div>
  </div>

  <div class="modal" id="mapModal">
    <div class="panel">
      <h3 style="margin-top:0;">Map your Excel/CSV columns</h3>
      <p class="small">Choose columns for <b>SKU</b>, <b>Quantity</b>, and (optional) <b>Description</b>.</p>
      <div class="row" style="margin-top:8px;">
        <label>SKU: <select id="mapSku"></select></label>
        <label>Qty: <select id="mapQty"></select></label>
        <label>Desc (optional): <select id="mapDesc"></select></label>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="mapConfirm" class="primary">Use These Columns</button>
        <button id="mapCancel">Cancel</button>
        <span class="small" id="mapPreview"></span>
      </div>
    </div>
  </div>
</div>

<!-- Socket.IO client -->
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
<script>
(() => {
  // ------------------------------
  // REAL-TIME: socket + helpers
  // ------------------------------
  const socket = io();
  let sharedVersion = 0;
  let isApplyingRemote = false;
  const stationName = (localStorage.getItem("station_name")) || (() => {
    const n = prompt("Station name (e.g., 'Scanner-1')", location.hostname || "station");
    if (n) localStorage.setItem("station_name", n);
    return n || "station";
  })();

  function snapshotState(){
    return {
      master: Array.from(state.master.entries()),
      unknown: Array.from(state.unknown.entries()),
      history: state.history,
      options: state.options,
      remainingOrder: state.remainingOrder,
      remainingOrderNext: state.remainingOrderNext,
      remainingFilter: state.remainingFilter,
      matchedFilter: state.matchedFilter
    };
  }
  function hydrateFromSnapshot(obj){
    state.master = new Map(obj.master || []);
    state.master.forEach((v,k)=>{ if (v && typeof v === "object") { if (!v.key) v.key = k; } });
    state.unknown = new Map(obj.unknown || []);
    state.history = obj.history || [];
    Object.assign(state.options, obj.options || {});
    state.remainingOrder = obj.remainingOrder || {};
    state.remainingOrderNext = obj.remainingOrderNext || 0;
    state.remainingFilter = obj.remainingFilter || '';
    state.matchedFilter = obj.matchedFilter || '';
    // reflect options & filters in UI
    els.optCase.checked = state.options.caseInsensitive;
    els.optTrim.checked = state.options.trim;
    els.optIgnoreWS.checked = state.options.ignoreWhitespace;
    els.optDropNonAlnum.checked = state.options.dropNonAlnum;
    els.optStripZeros.checked = state.options.stripLeadingZeros;
    els.optBeep.checked = state.options.beep;
    if (els.filterRemaining) els.filterRemaining.value = state.remainingFilter;
    if (els.filterMatched) els.filterMatched.value = state.matchedFilter;
    renderAll();
  }
  function broadcast(){
    if (isApplyingRemote) return;
    socket.emit("state:updateFull", {
      version: sharedVersion,
      state: snapshotState(),
      actor: stationName
    });
  }
  socket.on("state:full", ({ version, state: remote }) => {
    isApplyingRemote = true;
    sharedVersion = version;
    hydrateFromSnapshot(remote || {});
    isApplyingRemote = false;
  });
  socket.on("state:error", (e) => alert(e?.message || "Sync error"));

  // ------------------------------
  // APP STATE (your original logic)
  // ------------------------------
  const state = {
    master: new Map(),
    unknown: new Map(),
    history: [],
    options: { caseInsensitive:true, trim:true, ignoreWhitespace:true, dropNonAlnum:true, stripLeadingZeros:false, beep:true },
    importBuffer: null,
    remainingOrder: {},
    remainingOrderNext: 0,
    remainingFilter: '',
    matchedFilter: ''
  };

  // ------------------------------
  // KEY / NORMALIZATION HELPERS
  // ------------------------------
  function normalize(s) {
    if (s == null) return '';
    let x = String(s);
    if (state.options.trim) x = x.trim();
    if (state.options.ignoreWhitespace) x = x.replace(/\s+/g, '');
    if (state.options.dropNonAlnum) x = x.replace(/[^0-9A-Za-z]/g, '');
    if (state.options.stripLeadingZeros) x = x.replace(/^0+/, '');
    if (state.options.caseInsensitive) x = x.toUpperCase();
    return x;
  }
  function isManualOnlySku(normSku){ return !normSku || normSku === 'ABEL'; }
  function makeKey(sku, desc) {
    const nSku = normalize(sku);
    if (isManualOnlySku(nSku)) {
      const nDesc = (desc ?? '').toString().trim().toUpperCase();
      return (nSku || '__BLANK__') + '|' + nDesc;
    }
    return nSku;
  }
  function getEntryByKey(key){ return state.master.get(key); }

  // ------------------------------
  // CSV/TSV PARSING
  // ------------------------------
  function parseDelimited(text) {
    const delim = text.indexOf('\t') !== -1 ? '\t' : ',';
    const rows = [];
    let field = '', row = [], inQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') { if (text[i+1] === '"') { field += '"'; i++; } else inQuotes = false; }
        else field += c;
      } else {
        if (c === '"') inQuotes = true;
        else if (c === delim) { row.push(field); field=''; }
        else if (c === '\n') { row.push(field); rows.push(row); row=[]; field=''; }
        else if (c === '\r') { /* skip */ }
        else field += c;
      }
    }
    row.push(field); rows.push(row);
    if (rows.length && rows[rows.length-1].every(x=>x==='')) rows.pop();
    return rows;
  }
  function toHeaderIndex(headers) {
    const map = {}; headers.forEach((h,i)=> map[String(h||'').trim().toLowerCase()] = i);
    const skuIdx = ['sku','barcode','upc','ean','id','code','item','itemcode','productcode'].map(k => map[k]).find(i => i !== undefined);
    const qtyIdx = ['qty','quantity','count','onhand','on_hand','expected','expectedqty'].map(k => map[k]).find(i => i !== undefined);
    const descIdx = ['description','desc','name','title','product','itemname'].map(k => map[k]).find(i => i !== undefined);
    return { skuIdx, qtyIdx, descIdx, map };
  }

  // ------------------------------
  // DOM CACHE
  // ------------------------------
  const els = {
    masterFile: document.getElementById('masterFile'),
    loadMasterBtn: document.getElementById('loadMasterBtn'),
    masterPaste: document.getElementById('masterPaste'),
    loadPasteBtn: document.getElementById('loadPasteBtn'),
    scanInput: document.getElementById('scanInput'),
    undoBtn: document.getElementById('undoBtn'),
    exportBtn: document.getElementById('exportBtn'),
    clearBtn: document.getElementById('clearBtn'),
    optCase: document.getElementById('optCase'),
    optTrim: document.getElementById('optTrim'),
    optIgnoreWS: document.getElementById('optIgnoreWS'),
    optDropNonAlnum: document.getElementById('optDropNonAlnum'),
    optStripZeros: document.getElementById('optStripZeros'),
    optBeep: document.getElementById('optBeep'),
    kExpected: document.getElementById('kExpected'),
    kExpectedQty: document.getElementById('kExpectedQty'),
    kScannedQty: document.getElementById('kScannedQty'),
    kRemainingQty: document.getElementById('kRemainingQty'),
    kUnknownQty: document.getElementById('kUnknownQty'),
    remainingTable: document.querySelector('#remainingTable tbody'),
    matchedTable: document.querySelector('#matchedTable tbody'),
    unknownTable: document.querySelector('#unknownTable tbody'),
    log: document.getElementById('log'),
    mapModal: document.getElementById('mapModal'),
    mapSku: document.getElementById('mapSku'),
    mapQty: document.getElementById('mapQty'),
    mapDesc: document.getElementById('mapDesc'),
    mapConfirm: document.getElementById('mapConfirm'),
    mapCancel: document.getElementById('mapCancel'),
    mapPreview: document.getElementById('mapPreview'),
    filterRemaining: document.getElementById('filterRemaining'),
    filterMatched: document.getElementById('filterMatched')
  };

  const STORAGE_KEY = 'inv-scan-v3-scanned-remaining';

  // ------------------------------
  // PERSISTENCE (local backup + realtime broadcast)
  // ------------------------------
  function save() {
    // local backup so a single device can recover
    localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshotState()));
    // broadcast to all clients via server
    broadcast();
  }
  function load() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    try {
      hydrateFromSnapshot(JSON.parse(raw));
    } catch(e) { console.error(e); }
  }

  // ------------------------------
  // REMAINING ORDER HELPERS
  // ------------------------------
  function initRemainingOrder() {
    state.remainingOrder = state.remainingOrder || {};
    state.remainingOrderNext = state.remainingOrderNext || 0;
    const initial = Array.from(state.master.values())
      .filter(e => (e.expected || 0) - (e.scanned || 0) > 0)
      .sort((a,b) => ((b.expected - b.scanned) - (a.expected - a.scanned)) || (a.sku||'').localeCompare(b.sku||''));
    for (const e of initial) {
      if (state.remainingOrder[e.key] == null) state.remainingOrder[e.key] = state.remainingOrderNext++;
    }
  }
  function ensureOrderForKey(key) {
    if (state.remainingOrder[key] == null) state.remainingOrder[key] = state.remainingOrderNext++;
  }

  // ------------------------------
  // EXCEL LOADER
  // ------------------------------
  async function loadExcel(file) {
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, { type: 'array' });
    const sheetName = wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    const aoa = XLSX.utils.sheet_to_json(ws, { header:1, raw:true });
    loadMasterFromRows(aoa);
  }

  // ------------------------------
  // COLUMN MAPPING MODAL
  // ------------------------------
  function openMapper(headers) {
    function fillSelect(sel, opts) {
      sel.innerHTML = '';
      const empty = document.createElement('option'); empty.value=''; empty.textContent='--';
      sel.appendChild(empty);
      opts.forEach((h, i) => { const o = document.createElement('option'); o.value = i; o.textContent = h || `col${i}`; sel.appendChild(o); });
    }
    fillSelect(els.mapSku, headers);
    fillSelect(els.mapQty, headers);
    fillSelect(els.mapDesc, headers);
    const auto = toHeaderIndex(headers);
    if (auto.skuIdx !== undefined) els.mapSku.value = auto.skuIdx;
    if (auto.qtyIdx !== undefined) els.mapQty.value = auto.qtyIdx;
    if (auto.descIdx !== undefined) els.mapDesc.value = auto.descIdx;
    els.mapPreview.textContent = `Headers: ${headers.map(h=>`[${h}]`).join(' ')}`;
    els.mapModal.style.display = 'flex';
  }
  function closeMapper(){ els.mapModal.style.display = 'none'; }

  // ------------------------------
  // MASTER LOAD
  // ------------------------------
  function loadMasterFromRows(rows, mapping) {
    if (!rows.length) throw new Error('No rows found');
    const headers = rows[0];
    const idx = mapping || toHeaderIndex(headers);
    if (!mapping && (idx.skuIdx === undefined || idx.qtyIdx === undefined)) {
      openMapper(headers, rows.slice(1,6));
      state.importBuffer = rows;
      return;
    }
    const skuIdx = mapping ? mapping.skuIdx : idx.skuIdx;
    const qtyIdx = mapping ? mapping.qtyIdx : idx.qtyIdx;
    const descIdx = mapping ? mapping.descIdx : idx.descIdx;
    const master = new Map();
    let total = 0;
    for (let i = 1; i < rows.length; i++) {
      const r = rows[i]; if (!r || r.length === 0) continue;
      const skuRaw = r[skuIdx] ?? '';
      const qtyRaw = r[qtyIdx] ?? '0';
      const descRaw = descIdx !== undefined ? (r[descIdx] ?? '') : '';
      const qty = Number(String(qtyRaw).trim().replace(/,/g,'')) || 0;
      const normSku = normalize(skuRaw);
      const manualOnly = isManualOnlySku(normSku);
      const key = makeKey(skuRaw, descRaw);
      if (!master.has(key)) {
        master.set(key, { key, sku: String(skuRaw).trim(), desc: String(descRaw).trim(), expected: 0, scanned: 0, manualOnly });
      }
      const entry = master.get(key);
      entry.expected += qty;
      entry.manualOnly = entry.manualOnly || manualOnly;
      total += qty;
    }
    state.master = master;
    state.unknown = new Map();
    state.history = [];
    state.remainingOrder = {}; state.remainingOrderNext = 0;
    initRemainingOrder();
    save(); renderAll();
    toast(`Master loaded: ${master.size} items, total qty ${total}`, true);
  }

  // ------------------------------
  // SCANNING (double-scan guard + no-over + error beep when already complete)
  // ------------------------------
  let lastScan = { norm:null, ts:0 };
  const DOUBLE_SCAN_MS = 300;

  function scan(value) {
    const ts = new Date().toISOString();
    const norm = normalize(value);
    if (!norm) return;

    const now = Date.now();
    if (norm === lastScan.norm && now - lastScan.ts < DOUBLE_SCAN_MS) return;
    lastScan = { norm, ts: now };

    if (norm === 'ABEL') { flash('ABEL must be marked with the Shot button', false); beep(false); return; }

    let entry = null;
    for (const e of state.master.values()) {
      if (!e.manualOnly && normalize(e.sku) === norm) { entry = e; break; }
    }

    if (entry) {
      const remaining = Math.max(0, (entry.expected || 0) - (entry.scanned || 0));
      if (remaining <= 0) {
        flash('Already complete: ' + (entry.sku || norm), false);
        beep(false);
        return;
      }
      entry.scanned += 1;
      state.history.push({ type:'known', key: entry.key, norm, ts });
      flash('MATCH: ' + (entry.sku || norm), true); beep(true);
    } else {
      const prev = state.unknown.get(norm) || 0;
      state.unknown.set(norm, prev + 1);
      state.history.push({ type:'unknown', norm, ts });
      flash('UNKNOWN: ' + value, false); beep(false);
    }
    if (state.history.length > 5000) state.history.shift();
    save(); renderAll();
  }

  function manualShot(key, amount = 1) {
    const entry = getEntryByKey(key);
    if (!entry) { flash('Not in master', false); beep(false); return; }

    const before = Math.max(0, (entry.expected||0) - (entry.scanned||0));
    if (before <= 0) {
      flash('Already complete: ' + (entry.sku || '(no sku)'), false);
      beep(false);
      return;
    }

    const add = Math.min(amount, before);
    entry.scanned = (entry.scanned || 0) + add;
    state.history.push({ type: 'known', key: entry.key, ts: new Date().toISOString(), src: 'manual' });
    save(); renderAll();

    const after = Math.max(0, (entry.expected||0) - (entry.scanned||0));
    flash(after <= 0 ? ('Completed: ' + (entry.sku || '(no sku)')) : (`Shot +${add} → ${after} remaining`), true);
    beep(true);
  }

  function undo() {
    const last = state.history.pop();
    if (!last) return;
    if (last.type === 'known') {
      const e = last.key ? getEntryByKey(last.key) : null;
      if (e && e.scanned > 0) e.scanned -= 1;
    } else {
      const c = state.unknown.get(last.norm) || 0;
      if (c <= 1) state.unknown.delete(last.norm); else state.unknown.set(last.norm, c - 1);
    }
    save(); renderAll(); toast('Undid last scan', true);
  }

  // ------------------------------
  // RENDERING
  // ------------------------------
  function renderAll() {
    const entries = Array.from(state.master.values());
    const expectedDistinct = entries.length;
    const expectedQty = entries.reduce((a, e) => a + (e.expected||0), 0);
    const scannedQty = entries.reduce((a, e) => a + (e.scanned||0), 0);
    const remainingQty = entries.reduce((a, e) => a + Math.max(0, (e.expected||0) - (e.scanned||0)), 0);
    const unknownQty = Array.from(state.unknown.values()).reduce((a, n) => a + n, 0);
    els.kExpected.textContent = expectedDistinct;
    els.kExpectedQty.textContent = expectedQty;
    els.kScannedQty.textContent = scannedQty;
    els.kRemainingQty.textContent = remainingQty;
    els.kUnknownQty.textContent = unknownQty;

    const remaining = entries.filter(e => (e.expected||0) - (e.scanned||0) > 0);
    const qRem = (state.remainingFilter || '').toString().trim().toUpperCase();
    const filteredRemaining = qRem ? remaining.filter(e => {
      const skuU = (e.sku || '').toString().toUpperCase();
      const descU = (e.desc || '').toUpperCase();
      return skuU.includes(qRem) || descU.includes(qRem);
    }) : remaining;

    for (const e of filteredRemaining) ensureOrderForKey(e.key);
    filteredRemaining.sort((a,b) => state.remainingOrder[a.key] - state.remainingOrder[b.key]);

    renderTable(els.remainingTable, filteredRemaining.map(e => {
      const remainingLeft = Math.max(0, (e.expected||0) - (e.scanned||0));
      return [
        e.sku || '(no sku)',
        e.desc || '',
        String(e.scanned||0),
        String(remainingLeft),
        `<button class="mini" data-action="shot" data-key="${e.key}">Shot +1</button>`
      ];
    }));

    const qMat = (state.matchedFilter || '').toString().trim().toUpperCase();
    const matched = entries.filter(e => {
      if (!qMat) return true;
      const skuU = (e.sku || '').toString().toUpperCase();
      const descU = (e.desc || '').toUpperCase();
      return skuU.includes(qMat) || descU.includes(qMat);
    }).sort((a,b)=> (a.sku||'').localeCompare(b.sku||''));

    renderTable(els.matchedTable, matched.map(e => {
      const status = (e.scanned||0) < (e.expected||0) ? 'short' : 'ok';
      return { rowClass: status, cells: [
        e.sku||'(no sku)', e.desc||'', String(e.expected||0), String(e.scanned||0),
        `<span class="pill ${status}">${status.toUpperCase()}</span>`
      ]};
    }), true);

    const unkRows = Array.from(state.unknown.entries()).sort((a,b)=> b[1]-a[1]).map(([norm,count])=>[norm, String(count)]);
    renderTable(els.unknownTable, unkRows);

    const logLines = state.history.slice(-50).map(h => {
      const time = new Date(h.ts).toLocaleTimeString();
      if (h.type === 'known') {
        const e = h.key ? getEntryByKey(h.key) : null;
        return `[${time}] OK  → ${e ? (e.sku || e.key) : (h.norm || '')}${h.src==='manual' ? ' (manual)' : ''}`;
      } else {
        return `[${time}] ??? → ${h.norm}`;
      }
    });
    els.log.textContent = logLines.reverse().join('\n');
  }

  function renderTable(tbody, rows, withClass=false) {
    tbody.innerHTML = '';
    for (const r of rows) {
      const tr = document.createElement('tr');
      if (withClass && r.rowClass) tr.className = r.rowClass;
      const cells = withClass ? r.cells : r;
      for (const c of cells) {
        const td = document.createElement('td');
        if (typeof c === 'string' && c.startsWith('<')) td.innerHTML = c; else td.textContent = c;
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }

  // ------------------------------
  // AUDIO + TOAST FEEDBACK
  // ------------------------------
  let audioCtx = null;
  function ensureAudio(){ if (!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} } }
  function beep(ok){ if(!state.options.beep) return; ensureAudio(); if(!audioCtx) return;
    const duration = ok ? 0.10 : 0.22; const freq = ok ? 900 : 180; const peak = ok ? 0.18 : 0.22;
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = ok ? 'square' : 'sawtooth'; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.connect(gain); gain.connect(audioCtx.destination);
    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(peak, audioCtx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    osc.start(); osc.stop(audioCtx.currentTime + duration + 0.05);
  }
  function flash(msg, ok){ const overlay = document.createElement('div'); overlay.style.cssText="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:50";
    const bubble = document.createElement('div'); bubble.textContent = msg; bubble.style.cssText = "padding:14px 22px;border-radius:12px;font-size:18px;font-weight:700;border:1px solid var(--border);box-shadow:0 10px 40px rgba(0,0,0,0.35);background:" + (ok?"rgba(34,197,94,0.2)":"rgba(239,68,68,0.2)");
    overlay.appendChild(bubble); document.body.appendChild(overlay); setTimeout(()=>overlay.remove(), 600); }
  function toast(msg, ok){ flash(msg, ok); }

  // ------------------------------
  // OPTIONS + EVENTS
  // ------------------------------
  function setOptionsFromUI() {
    state.options.caseInsensitive = els.optCase.checked;
    state.options.trim = els.optTrim.checked;
    state.options.ignoreWhitespace = els.optIgnoreWS.checked;
    state.options.dropNonAlnum = els.optDropNonAlnum.checked;
    state.options.stripLeadingZeros = els.optStripZeros.checked;
    state.options.beep = els.optBeep.checked;
    save();
  }
  [els.optCase, els.optTrim, els.optIgnoreWS, els.optDropNonAlnum, els.optStripZeros, els.optBeep]
    .forEach(el => el.addEventListener('change', () => { setOptionsFromUI(); renderAll(); }));

  function focusScan(){ els.scanInput?.focus({ preventScroll:true }); }
  document.addEventListener('click', (e)=>{
    const t = e.target;
    if (t.closest('input, textarea, select, button, .modal')) return;
    focusScan();
  });
  window.addEventListener('focus', focusScan);

  els.scanInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      const v = e.currentTarget.value; e.currentTarget.value='';
      if (v) scan(v); e.preventDefault();
    }
  });
  els.scanInput.addEventListener('input', (e)=>{
    const v = e.currentTarget.value;
    if (v && v.endsWith('\n')) { e.currentTarget.value = v.replace(/\n+$/,''); if (e.currentTarget.value) scan(e.currentTarget.value); e.currentTarget.value=''; }
  });

  els.undoBtn.addEventListener('click', undo);
  els.clearBtn.addEventListener('click', ()=>{ if (!confirm('Clear current session (master, scans, options)?')) return;
    state.master.clear(); state.unknown.clear(); state.history = [];
    state.remainingOrder = {}; state.remainingOrderNext = 0;
    save(); renderAll(); });

  els.exportBtn.addEventListener('click', ()=>{
    const rows = [['sku','description','expected_qty','scanned_qty','status']];
    for (const e of state.master.values()) {
      const status = (e.scanned || 0) < (e.expected || 0) ? 'SHORT' : 'OK';
      rows.push([e.sku || '', e.desc || '', e.expected||0, e.scanned||0, status]);
    }
    if (state.unknown.size) { rows.push([]); rows.push(['unknown_sku','count']); for (const [sku,count] of state.unknown.entries()) rows.push([sku,count]); }
    const csv = rows.map(r => r.map(cell => { const s = String(cell ?? ''); return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s; }).join(',')).join('\n');
    const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='inventory_reconcile.csv'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  els.loadMasterBtn.addEventListener('click', async ()=>{
    const f = els.masterFile.files?.[0]; if (!f) { alert('Choose a file first.'); return; }
    try {
      if (/\.(xlsx|xls)$/i.test(f.name) || (f.type && (f.type.includes('sheet') || f.type.includes('excel')))) {
        await loadExcel(f);
      } else {
        const text = await f.text(); const rows = parseDelimited(text); loadMasterFromRows(rows);
      }
    } catch (e) { alert(e.message || String(e)); }
  });

  els.loadPasteBtn.addEventListener('click', ()=>{
    const text = els.masterPaste.value;
    if (!text.trim()) { alert('Paste data first.'); return; }
    try { const rows = parseDelimited(text); loadMasterFromRows(rows); } catch(e){ alert(e.message || String(e)); }
  });

  els.filterRemaining.addEventListener('input', (e)=>{ state.remainingFilter = e.target.value; save(); renderAll(); });
  els.filterMatched.addEventListener('input', (e)=>{ state.matchedFilter = e.target.value; save(); renderAll(); });

  els.mapConfirm.addEventListener('click', ()=>{
    if (!state.importBuffer) return closeMapper();
    const skuIdx = els.mapSku.value === '' ? undefined : Number(els.mapSku.value);
    const qtyIdx = els.mapQty.value === '' ? undefined : Number(els.mapQty.value);
    const descIdx = els.mapDesc.value === '' ? undefined : Number(els.mapDesc.value);
    if (skuIdx === undefined || qtyIdx === undefined) { alert('Please select at least SKU and Qty columns.'); return; }
    closeMapper();
    loadMasterFromRows(state.importBuffer, { skuIdx, qtyIdx, descIdx });
    state.importBuffer = null;
  });
  els.mapCancel.addEventListener('click', ()=>{ state.importBuffer = null; closeMapper(); });

  els.remainingTable.addEventListener('click', (ev) => {
    const btn = ev.target.closest('[data-action="shot"]');
    if (!btn) return;
    manualShot(btn.dataset.key, 1);
  });

  // Local backup first; server snapshot will overwrite after socket connects
  load();
  function focusScan(){ els.scanInput?.focus({ preventScroll:true }); }
  focusScan();
})();
</script>
</body>
</html>
